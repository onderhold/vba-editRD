onderhold: @workspace find the code which effectively does the export operation for VBA code. I want to change/enhance it.

Workspace: Sammeln von Arbeitsbereichsinformationen
Der Code für die VBA-Export-Operation befindet sich in der `ExcelVBAHandler` Klasse. Hier ist die relevante Code-Hierarchie:

## 1. CLI Entry Point
In `excel_vba.py` Zeile 243 wird der Export ausgelöst:
```python
elif args.command == "export":
    handler.export_vba(save_metadata=getattr(args, "save_metadata", False), overwrite=True)
```

## 2. Haupt-Export-Methode
Die Kern-Export-Logik ist in `OfficeVBAHandler.export_vba()` ab Zeile 1086:

```python
def export_vba(self, save_metadata: bool = False, overwrite: bool = True) -> None:
    """Export VBA modules to files."""
    # Holt VBA-Projekt und Components
    vba_project = self.get_vba_project()
    components = vba_project.VBComponents
    
    # Iteriert durch alle VBA-Komponenten
    for component in components:
        # Exportiert jede Komponente einzeln
        self.export_component(component, self.vba_dir)
```

## 3. Einzelkomponenten-Export
Die detaillierte Export-Logik für einzelne VBA-Komponenten ist in `OfficeVBAHandler.export_component()` ab Zeile 705:

```python
def export_component(self, component: Any, directory: Path) -> None:
    """Export a single VBA component."""
    # 1. Exportiert Komponente in temporäre Datei
    component.Export(str(temp_file))
    
    # 2. Liest und verarbeitet Inhalt
    with open(temp_file, "r", encoding=self.encoding) as f:
        content = f.read()
    
    # 3. Teilt Content in Header und Code
    header, code = self.component_handler.split_vba_content(content)
    
    # 4. Schreibt finale Dateien
    self._write_component_files(name, header, code, info, directory)
```

## 4. Content-Processing
Die Aufspaltung von VBA-Content erfolgt in `VBAComponentHandler.split_vba_content()` ab Zeile 317:

```python
def split_vba_content(self, content: str) -> Tuple[str, str]:
    """Split VBA content into header and code sections."""
    # Trennt VB_Attribute (Header) vom eigentlichen Code
```

## 5. File-Writing
Das finale Schreiben der Dateien erfolgt in `OfficeVBAHandler._write_component_files()` ab Zeile 918:

```python
def _write_component_files(self, name: str, header: str, code: str, info: Dict[str, Any], directory: Path) -> None:
    # Schreibt .header Datei (falls save_headers=True)
    # Schreibt .bas/.cls/.frm Code-Datei
```

## Was möchten Sie ändern/erweitern?

Die Export-Funktionalität ist modular aufgebaut:
- **Metadata**: `_save_metadata()` speichert Encoding-Informationen
- **Form-Binaries**: `_handle_form_binary_export()` behandelt .frx Dateien
- **Component-Info**: `VBAComponentHandler.get_component_info()` sammelt Modul-Metadaten

Welchen spezifischen Aspekt der Export-Operation möchten Sie erweitern oder ändern?

onderhold: I want to enhance the code such that it considers Rubberduck folder annotations if they are present and stores each module in a corresponding folder tree in the file system when exporting. There should also be an command option whether this shall be done or not. The same applies to the importing of VBA code, where the subtree gets applied to the folder annotation in the VBA code and even adds one if one is not already present. 

GitHub Copilot: Ich erstelle eine Lösung, die Rubberduck-Ordner-Annotationen unterstützt. Hier sind die Änderungen:

## 1. Erweiterte VBAComponentHandler Klasse

````python
class VBAComponentHandler:
    """Handles VBA component operations independent of Office application type."""

    def __init__(self, use_rubberduck_folders: bool = False):
        """Initialize the component handler.
        
        Args:
            use_rubberduck_folders: Whether to process Rubberduck folder annotations
        """
        self.use_rubberduck_folders = use_rubberduck_folders

    def extract_rubberduck_folder(self, code: str) -> Tuple[str, str]:
        """Extract Rubberduck @Folder annotation from VBA code.
        
        Args:
            code: VBA code content
            
        Returns:
            Tuple of (folder_path, code_without_annotation)
        """
        if not self.use_rubberduck_folders:
            return "", code
            
        lines = code.splitlines()
        folder_path = ""
        filtered_lines = []
        
        for line in lines:
            stripped = line.strip()
            # Look for @Folder annotation (case insensitive)
            if stripped.lower().startswith("'@folder"):
                # Extract folder path
                match = re.match(r"'@folder\s*\(\s*[\"']([^\"']+)[\"']\s*\)", stripped, re.IGNORECASE)
                if match:
                    folder_path = match.group(1).replace(".", os.sep)
                # Skip this line in the output
                continue
            filtered_lines.append(line)
        
        return folder_path, "\n".join(filtered_lines)

    def add_rubberduck_folder(self, code: str, folder_path: str) -> str:
        """Add Rubberduck @Folder annotation to VBA code.
        
        Args:
            code: VBA code content
            folder_path: Folder path to add
            
        Returns:
            Code with @Folder annotation added
        """
        if not self.use_rubberduck_folders or not folder_path:
            return code
            
        # Convert filesystem path to Rubberduck notation
        rubberduck_path = folder_path.replace(os.sep, ".")
        folder_annotation = f"'@Folder(\"{rubberduck_path}\")"
        
        lines = code.splitlines()
        
        # Find insertion point (after attributes, before actual code)
        insert_index = 0
        in_attributes = True
        
        for i, line in enumerate(lines):
            stripped = line.strip()
            
            # Skip empty lines at the beginning
            if not stripped and in_attributes:
                continue
                
            # Check if we're still in attributes section
            if stripped.startswith("Attribute ") or stripped.startswith("VERSION ") or stripped.startswith("BEGIN"):
                insert_index = i + 1
                continue
                
            # Found first non-attribute line
            in_attributes = False
            
            # Skip existing @Folder annotations
            if stripped.lower().startswith("'@folder"):
                continue
                
            # This is where we want to insert
            insert_index = i
            break
        
        # Insert the folder annotation
        lines.insert(insert_index, folder_annotation)
        
        return "\n".join(lines)

    def get_folder_from_file_path(self, file_path: Path, vba_base_dir: Path) -> str:
        """Extract folder path from file system location.
        
        Args:
            file_path: Path to the VBA file
            vba_base_dir: Base VBA directory
            
        Returns:
            Relative folder path
        """
        if not self.use_rubberduck_folders:
            return ""
            
        try:
            relative_path = file_path.relative_to(vba_base_dir)
            folder_path = str(relative_path.parent)
            
            # Return empty string for root directory
            if folder_path == ".":
                return ""
                
            return folder_path
        except ValueError:
            # File is not under vba_base_dir
            return ""

    # ... existing methods remain unchanged ...
````

## 2. Erweiterte OfficeVBAHandler Klasse

````python
class OfficeVBAHandler(ABC):
    """Abstract base class for handling VBA operations across Office applications."""

    def __init__(
        self,
        doc_path: str,
        vba_dir: Optional[str] = None,
        encoding: str = "cp1252",
        verbose: bool = False,
        save_headers: bool = False,
        use_rubberduck_folders: bool = False,
    ):
        """Initialize the VBA handler."""
        try:
            # Let DocumentNotFoundError propagate as is - it's more fundamental than VBA errors
            self.doc_path, self.vba_dir = get_document_paths(doc_path, None, vba_dir)
            self.encoding = encoding
            self.verbose = verbose
            self.save_headers = save_headers
            self.use_rubberduck_folders = use_rubberduck_folders
            self.app = None
            self.doc = None
            self.component_handler = VBAComponentHandler(use_rubberduck_folders)

            # Configure logging
            log_level = logging.DEBUG if verbose else logging.INFO
            logger.setLevel(log_level)

            logger.debug(f"Initialized {self.__class__.__name__} with document: {doc_path}")
            logger.debug(f"VBA directory: {self.vba_dir}")
            logger.debug(f"Using encoding: {encoding}")
            logger.debug(f"Save headers: {save_headers}")
            logger.debug(f"Rubberduck folders: {use_rubberduck_folders}")

        except DocumentNotFoundError:
            raise  # Let it propagate
        except Exception as e:
            raise VBAError(f"Failed to initialize VBA handler: {str(e)}") from e

    def export_component(self, component: Any, directory: Path) -> None:
        """Export a single VBA component with Rubberduck folder support."""
        temp_file = None
        try:
            logger.debug(f"Starting component export for {component.Name}")
            info = self.component_handler.get_component_info(component)
            name = info["name"]
            logger.debug(f"Exporting component {name} with save_headers={self.save_headers}")
            temp_file = resolve_path(f"{name}.tmp", directory)

            # Export to temp file
            logger.debug("About to call component.Export")
            component.Export(str(temp_file))
            logger.debug("Component.Export completed")

            # Read and process content
            with open(temp_file, "r", encoding=self.encoding) as f:
                content = f.read()

            # Split content
            header, code = self.component_handler.split_vba_content(content)
            
            # Extract Rubberduck folder if enabled
            folder_path = ""
            if self.use_rubberduck_folders:
                folder_path, code = self.component_handler.extract_rubberduck_folder(code)

            # Determine target directory
            target_directory = directory
            if folder_path:
                target_directory = directory / folder_path
                target_directory.mkdir(parents=True, exist_ok=True)
                logger.debug(f"Created folder structure: {target_directory}")

            # Write files
            self._write_component_files(name, header, code, info, target_directory)
            logger.debug(f"Component files written for {name} in {target_directory}")

            logger.info(f"Exported: {name}" + (f" (folder: {folder_path})" if folder_path else ""))

        except Exception as e:
            logger.error(f"Failed to export component {component.Name}: {str(e)}")
            raise VBAError(f"Failed to export component {component.Name}") from e
        finally:
            if temp_file and Path(temp_file).exists():
                try:
                    Path(temp_file).unlink()
                except OSError:
                    pass

    def import_vba(self) -> None:
        """Import VBA content with Rubberduck folder support."""
        try:
            # First check if document is accessible
            if self.doc is None:
                self.open_document()
            _ = self.doc.Name  # Check connection

            vba_project = self.get_vba_project()
            components = vba_project.VBComponents

            # Find all VBA files recursively if Rubberduck folders are enabled
            vba_files = []
            if self.use_rubberduck_folders:
                # Search recursively
                for ext in [".cls", ".bas", ".frm"]:
                    vba_files.extend(self.vba_dir.rglob(f"*{ext}"))
            else:
                # Search only in root directory
                for ext in [".cls", ".bas", ".frm"]:
                    vba_files.extend(self.vba_dir.glob(f"*{ext}"))

            if not vba_files:
                logger.info("No VBA files found to import.")
                return

            logger.info(f"\nFound {len(vba_files)} VBA files to import:")
            for vba_file in vba_files:
                relative_path = vba_file.relative_to(self.vba_dir)
                logger.info(f"  - {relative_path}")

            # Import components
            for vba_file in vba_files:
                try:
                    self.import_component(vba_file, components)
                except Exception as e:
                    logger.error(f"Failed to import {vba_file.name}: {str(e)}")
                    continue

            # Save if we successfully imported files
            self.save_document()

        except Exception as e:
            if check_rpc_error(e):
                raise DocumentClosedError(self.document_type)
            raise VBAError(str(e))

    def import_component(self, file_path: Path, components: Any) -> None:
        """Import a VBA component with Rubberduck folder support."""
        try:
            name = file_path.stem
            module_type = self.component_handler.get_module_type(file_path)

            logger.debug(f"Processing module: {name} (Type: {module_type})")

            # Read code file
            code = self._read_code_file(file_path)
            
            # Add Rubberduck folder annotation if enabled
            if self.use_rubberduck_folders:
                folder_path = self.component_handler.get_folder_from_file_path(file_path, self.vba_dir)
                if folder_path:
                    code = self.component_handler.add_rubberduck_folder(code, folder_path)
                    logger.debug(f"Added @Folder annotation: {folder_path}")

            # Handle based on module type
            if module_type == VBAModuleType.DOCUMENT:
                logger.debug(f"Updating document module: {name}")
                self._update_document_module(name, code, components)
                return

            try:
                # Try to get existing component
                component = components(name)

                if self._should_force_import(module_type):
                    # Remove and reimport if required
                    logger.debug(f"Forcing full import for: {name}")
                    components.Remove(component)
                    self._import_new_module(name, code, module_type, components)
                else:
                    # Update existing module content in-place
                    logger.debug(f"Updating existing component: {name}")
                    self._update_module_content(component, code)

            except Exception:
                # Component doesn't exist, create new
                logger.debug(f"Creating new module: {name}")
                # For new modules, we need header information
                header = self._read_header_file(file_path)
                if not header and module_type in [VBAModuleType.CLASS, VBAModuleType.FORM]:
                    header = self.component_handler.create_minimal_header(name, module_type)
                    logger.debug(f"Created minimal header for new module: {name}")

                # Prepare content for new module
                content = self.component_handler.prepare_import_content(name, module_type, header, code)
                self._import_new_module(name, content, module_type, components)

            # Handle any form binaries if needed
            if module_type == VBAModuleType.FORM:
                self._handle_form_binary_import(name)

            logger.info(f"Successfully processed: {file_path.name}")

            # Only try to save for non-Access applications
            if self.app_name != "Access":
                self.save_document()

        except Exception as e:
            logger.error(f"Failed to handle {file_path.name}: {str(e)}")
            raise VBAError(f"Failed to handle {file_path.name}") from e

    def watch_changes(self) -> None:
        """Watch for changes in VBA files with Rubberduck folder support."""
        try:
            logger.info(f"Watching for changes in {self.vba_dir}...")
            last_check_time = time.time()
            check_interval = 30  # Check connection every 30 seconds

            # Setup file watcher with recursive support if Rubberduck folders are enabled
            if self.use_rubberduck_folders:
                # Watch recursively
                watcher = RegExpWatcher(
                    self.vba_dir,
                    re_files=r"^.*\.(cls|frm|bas)$",
                    ignore_paths=None,  # Watch all subdirectories
                )
            else:
                # Watch only root directory
                watcher = RegExpWatcher(
                    self.vba_dir,
                    re_files=r"^.*\.(cls|frm|bas)$",
                )

            while True:
                try:
                    # Check connection periodically
                    current_time = time.time()
                    if current_time - last_check_time >= check_interval:
                        if not self.is_document_open():
                            raise DocumentClosedError(self.document_type)
                        last_check_time = current_time
                        logger.debug("Connection check passed")

                    # Check for changes using watchgod
                    changes = watcher.check()
                    if changes:
                        logger.debug(f"Watchgod detected changes: {changes}")

                    for change_type, path in changes:
                        try:
                            path = Path(path)
                            if change_type == Change.deleted:
                                # Handle deleted files
                                logger.info(f"Detected deletion of {path.name}")
                                if not self.is_document_open():
                                    raise DocumentClosedError(self.document_type)

                                vba_project = self.get_vba_project()
                                components = vba_project.VBComponents
                                try:
                                    component = components(path.stem)
                                    components.Remove(component)
                                    logger.info(f"Removed component: {path.stem}")
                                    self.doc.Save()
                                except Exception:
                                    logger.debug(f"Component {path.stem} already removed or not found")

                            elif change_type in (Change.added, Change.modified):
                                # Handle both added and modified files the same way
                                action = "addition" if change_type == Change.added else "modification"
                                logger.debug(f"Processing {action} in {path}")
                                self.import_single_file(path)

                        except (DocumentClosedError, RPCError) as e:
                            raise e
                        except Exception as e:
                            logger.warning(f"Error handling changes (will retry): {str(e)}")
                            continue

                except (DocumentClosedError, RPCError) as error:
                    raise error
                except Exception as error:
                    logger.warning(f"Error in watch loop (will continue): {str(error)}")

                # Prevent excessive CPU usage but stay responsive
                time.sleep(0.5)

        except KeyboardInterrupt:
            logger.info("\nStopping VBA editor...")
        except (DocumentClosedError, RPCError) as error:
            raise error
        finally:
            logger.info("VBA editor stopped.")

    # ... rest of existing methods remain unchanged ...
````

## 3. CLI-Interface erweitern

````python
def create_cli_parser() -> argparse.ArgumentParser:
    """Create the command-line interface parser."""
    parser = argparse.ArgumentParser(
        prog="excel-vba",
        description="Excel VBA code editor integration",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
  excel-vba edit workbook.xlsm
  excel-vba export workbook.xlsm --save-headers
  excel-vba import workbook.xlsm
  excel-vba export workbook.xlsm --rubberduck-folders
        """,
    )

    parser.add_argument("file", help="Excel file (.xlsm)")
    parser.add_argument("command", choices=["edit", "import", "export"], help="Action to perform")
    parser.add_argument("--save-headers", action="store_true", help="Save VBA component headers to separate files")
    parser.add_argument("--save-metadata", action="store_true", help="Save encoding metadata")
    parser.add_argument("--encoding", default="cp1252", help="Character encoding for VBA files")
    parser.add_argument("--verbose", "-v", action="store_true", help="Enable verbose output")
    parser.add_argument("--vba-dir", help="Directory for VBA files (default: same as Excel file)")
    parser.add_argument(
        "--rubberduck-folders", 
        action="store_true", 
        help="Use Rubberduck @Folder annotations to organize files in subdirectories"
    )

    return parser

def handle_excel_vba_command(args: argparse.Namespace) -> None:
    """Handle the Excel VBA command."""
    try:
        setup_logging(verbose=args.verbose)
        logger.info(f"Starting {args.command} operation for {args.file}")

        # Create handler with Rubberduck support
        handler = ExcelVBAHandler(
            doc_path=args.file,
            vba_dir=args.vba_dir,
            encoding=args.encoding,
            verbose=args.verbose,
            save_headers=args.save_headers,
            use_rubberduck_folders=args.rubberduck_folders,
        )

        try:
            if args.command == "edit":
                handler.open_document()
                handler.export_vba(overwrite=False)
                handler.watch_changes()

            elif args.command == "import":
                handler.import_vba()

            elif args.command == "export":
                handler.export_vba(save_metadata=getattr(args, "save_metadata", False), overwrite=True)

        except (DocumentClosedError, RPCError) as e:
            logger.error(str(e))
            sys.exit(1)
        except VBAAccessError as e:
            logger.error(str(e))
            sys.exit(1)
        except VBAError as e:
            logger.error(f"VBA operation failed: {str(e)}")
            sys.exit(1)
        except Exception as e:
            logger.error(f"Unexpected error: {str(e)}")
            sys.exit(1)

    except KeyboardInterrupt:
        logger.info("\nOperation interrupted by user")
        sys.exit(0)
    except Exception as e:
        logger.error(f"Failed to start operation: {str(e)}")
        sys.exit(1)
    finally:
        logger.info("Excel VBA operation completed")
````

## 4. Gleiche Änderungen für Word und Access

Die gleichen Änderungen müssen in [`word_vba.py`](src/vba_edit/word_vba.py ) und [`access_vba.py`](src/vba_edit/access_vba.py ) vorgenommen werden - die CLI-Parser und Handler-Initialisierung sind identisch.

## 5. Handler-Klassen aktualisieren

````python
class WordVBAHandler(OfficeVBAHandler):
    """Microsoft Word specific implementation with Rubberduck support."""
    
    def __init__(
        self,
        doc_path: str,
        vba_dir: Optional[str] = None,
        encoding: str = "cp1252",
        verbose: bool = False,
        save_headers: bool = False,
        use_rubberduck_folders: bool = False,
    ):
        super().__init__(
            doc_path=doc_path,
            vba_dir=vba_dir,
            encoding=encoding,
            verbose=verbose,
            save_headers=save_headers,
            use_rubberduck_folders=use_rubberduck_folders,
        )
    
    # ... rest of methods remain unchanged ...

class ExcelVBAHandler(OfficeVBAHandler):
    """Microsoft Excel specific implementation with Rubberduck support."""
    
    def __init__(
        self,
        doc_path: str,
        vba_dir: Optional[str] = None,
        encoding: str = "cp1252",
        verbose: bool = False,
        save_headers: bool = False,
        use_rubberduck_folders: bool = False,
    ):
        super().__init__(
            doc_path=doc_path,
            vba_dir=vba_dir,
            encoding=encoding,
            verbose=verbose,
            save_headers=save_headers,
            use_rubberduck_folders=use_rubberduck_folders,
        )
    
    # ... rest of methods remain unchanged ...

class AccessVBAHandler(OfficeVBAHandler):
    """Microsoft Access specific implementation with Rubberduck support."""
    
    def __init__(
        self,
        doc_path: str,
        vba_dir: Optional[str] = None,
        encoding: str = "cp1252",
        verbose: bool = False,
        save_headers: bool = False,
        use_rubberduck_folders: bool = False,
    ):
        super().__init__(
            doc_path=doc_path,
            vba_dir=vba_dir,
            encoding=encoding,
            verbose=verbose,
            save_headers=save_headers,
            use_rubberduck_folders=use_rubberduck_folders,
        )
    
    # ... rest of methods remain unchanged ...
````

## Funktionsweise

**Export mit Rubberduck-Unterstützung:**
1. Code wird gescannt nach `'@Folder("Some.Folder.Path")` Annotationen
2. Ordnerstruktur wird erstellt: `vba_dir/Some/Folder/Path/`
3. Module werden in entsprechende Unterordner exportiert

**Import mit Rubberduck-Unterstützung:**
1. Dateisystem-Struktur wird gescannt (rekursiv)
2. Relative Pfade werden zu `@Folder` Annotationen konvertiert
3. Fehlende `@Folder` Annotationen werden automatisch hinzugefügt

**Verwendung:**
```bash
# Export mit Rubberduck-Ordnern
excel-vba export workbook.xlsm --rubberduck-folders

# Import mit Rubberduck-Ordnern  
excel-vba import workbook.xlsm --rubberduck-folders

# Edit-Modus mit Rubberduck-Ordnern
excel-vba edit workbook.xlsm --rubberduck-folders
```

Diese Implementierung ist vollständig rückwärtskompatibel - ohne `--rubberduck-folders` funktioniert alles wie bisher.